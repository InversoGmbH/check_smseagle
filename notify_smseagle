#!/usr/bin/python

# Copyright (C) 2016  NETWAYS GmbH, https://netways.de
#
# Author: Alexander A. Klimov <alexander.klimov@netways.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.


from argparse import ArgumentParser
from urllib.parse import urljoin
import json
import ssl
import sys
import urllib.request

__version__ = '1.0.0'


def commandline(args):
    """
    Defines the CLI Parser and parses the arguments
    """
    parser = ArgumentParser(description= "notify_smseagle (Version: %s)" % (__version__))

    parser.add_argument('-u', '--url', required=True,
                            help="URL to send the message to")
    parser.add_argument('-U', '--user',
                            help="User for the login")
    parser.add_argument('-P', '--password',
                            help="Password for the login")
    parser.add_argument('-t', '--to',
                            help="Recipient for the message")
    parser.add_argument('-m', '--message',
                            help="The message to send")
    parser.add_argument('-T', '--timeout', help='Seconds before connection times out (default 10)',
                        default=10,
                        type=int)
    parser.add_argument('--insecure',
                        action='store_true',
                        default=False,
                        help='Allow insecure SSL connections (default False)')

    return parser.parse_args(args)

def send_data(url, request, timeout, insecure):
    """
    Sends the data via HTTP. Basically a wrapper around urllib.
    What we need to send:

     Header: Content-Type: application/json
     Body: '{"params":
        {"to": "recipient",
         "login": "user",
         "message": "hello",
         "pass": "password"},
         "method": "sms.send_sms"}'
    """

    # Default context for connection
    ctx = ssl.create_default_context()
    if insecure is True:
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE

    response = urllib.request.urlopen(url=url, data=request, timeout=timeout, context=ctx) # pylint: disable=consider-using-with

    if response.getcode() != 200:
        raise RuntimeError("Could not get response")

    resp = response.read().decode()

    return resp

def create_request(args):
    """
    Small wrapper to build the request. Makes for easier testing
    """
    return urllib.request.Request(json.dumps({
        'method': 'sms.send_sms',
        'Content-Type': 'application/json',
        'params': {
            'login': args.user,
            'pass': args.password,
            'to': args.to,
            'message': args.message
        }
    }))

def main(args):

    url = urljoin(args.url, "/index.php/jsonrpc/sms")
    r = create_request(args)

    try:
        response = send_data(url=url, request=r, timeout=args.timeout, insecure=args.insecure)
    except Exception as data_exc: # pylint: disable=broad-except
        print('Could not connect to SMS Eagle', data_exc)
        return 3

    try:
        result = json.loads(response.strip())['result']
    except Exception as json_exc: # pylint: disable=broad-except
        print('Could not parse data', json_exc)
        return 3

    if not result.startswith('OK;'):
        print('Could not send message', result)
        return 2

    return 0

if __name__ == '__main__': # pragma: no cover
    try:
        ARGS = commandline(sys.argv[1:])
        sys.exit(main(ARGS))
    except Exception as e: # pylint: disable=broad-except
        print("Error", e)
        sys.exit(3)
